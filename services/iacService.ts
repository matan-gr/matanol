
import { GceResource } from '../types';

const sanitizeTfId = (name: string) => name.replace(/[^a-zA-Z0-9_-]/g, '_');

const getTerraformType = (type: string): string => {
    switch (type) {
        case 'INSTANCE': return 'google_compute_instance';
        case 'DISK': return 'google_compute_disk';
        case 'BUCKET': return 'google_storage_bucket';
        case 'CLOUD_SQL': return 'google_sql_database_instance';
        case 'GKE_CLUSTER': return 'google_container_cluster';
        case 'CLOUD_RUN': return 'google_cloud_run_v2_service'; 
        default: return 'google_compute_instance'; // Fallback
    }
};

export const generateTerraformCode = (resources: GceResource[], projectId: string): string => {
    const lines: string[] = [];
    
    lines.push(`# =============================================================================`);
    lines.push(`# Generated by Yalla Label - Governance Remediation`);
    lines.push(`# Project: ${projectId}`);
    lines.push(`# Timestamp: ${new Date().toISOString()}`);
    lines.push(`# =============================================================================\n`);

    resources.forEach(r => {
        const tfType = getTerraformType(r.type);
        const tfId = sanitizeTfId(r.name);
        
        lines.push(`resource "${tfType}" "${tfId}" {`);
        lines.push(`  name    = "${r.name}"`);
        lines.push(`  project = "${projectId}"`);
        
        if (r.zone && r.zone !== 'global') {
            // Some resources use 'location', others 'zone'
            const locationKey = r.type === 'CLOUD_RUN' || r.type === 'GKE_CLUSTER' ? 'location' : 'zone';
            lines.push(`  ${locationKey}    = "${r.zone}"`);
        }

        // Labels Block - The core value prop
        if (r.labels && Object.keys(r.labels).length > 0) {
            lines.push(`\n  labels = {`);
            Object.entries(r.labels).forEach(([k, v]) => {
                lines.push(`    "${k}" = "${v}"`);
            });
            lines.push(`  }`);
        } else {
            lines.push(`  # No labels currently assigned`);
        }

        // Add lifecycle ignore to prevent accidental destruction of other props
        lines.push(`\n  lifecycle {`);
        lines.push(`    # Prevent Terraform from reverting changes made in the dashboard`);
        lines.push(`    ignore_changes = [all]`);
        lines.push(`  }`);

        lines.push(`}\n`);
    });

    return lines.join('\n');
};

export const generateTerraformImports = (resources: GceResource[], projectId: string): string => {
    const lines: string[] = [];
    
    lines.push(`# Terraform Import Commands`);
    lines.push(`# Run these to bring unmanaged resources into your state file\n`);

    resources.forEach(r => {
        const tfType = getTerraformType(r.type);
        const tfId = sanitizeTfId(r.name);
        
        // Construct GCP Resource ID format
        let gcpId = '';
        if (r.type === 'INSTANCE' || r.type === 'DISK') {
            gcpId = `projects/${projectId}/zones/${r.zone}/${tfType === 'google_compute_disk' ? 'disks' : 'instances'}/${r.name}`;
        } else if (r.type === 'BUCKET') {
            gcpId = `${r.name}`;
        } else if (r.type === 'CLOUD_RUN') {
            gcpId = `projects/${projectId}/locations/${r.zone}/services/${r.name}`;
        } else if (r.type === 'CLOUD_SQL') {
            gcpId = `projects/${projectId}/instances/${r.name}`;
        } else if (r.type === 'GKE_CLUSTER') {
            gcpId = `projects/${projectId}/locations/${r.zone}/clusters/${r.name}`;
        }

        if (gcpId) {
            lines.push(`terraform import ${tfType}.${tfId} ${gcpId}`);
        }
    });

    return lines.join('\n');
};
